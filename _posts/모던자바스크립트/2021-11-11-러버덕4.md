---
layout: post
title: "[러버덕4]"
subtitle: "러버덕4"
categories: 모던자바스크립트
comments: true
tags: 
---

## 1. 전역객체의 빌트인 전역 프로퍼티 isNaN 은 왜 전역일까?

- isNaN : ES1부터 존재
- 왜 전역으로 만들었을까? > js 초창기에 많이 쓸거라고 생각했으니까!
- 전역 빌트인 프로퍼티, 전역 빌트인 전역 함수 모두 초기에 많이 쓸 줄 알고 만들었지만 요즘 많이 안쓴다.(eval 처럼)
- ES5부터 Number의 메서드로 Number.isNaN(), isFinitie() 등장
    - Number 사용하자!
- 그럼 모든 메소드 외워야할까?
    - 외울 필요 없어, 다만 이런게 존재한다는 것만 알아두기
    - 나중에 없는지 알고 만들면 정말 삽질 of 삽질
    

## 2. String.prototype.charAt() 과 Math.max() 의 차이는?

- String은 생성자 함수
- Math는 non 생성자 함수
- 생성자 함수는 자신의 프로토타입을 가진다.
- 생성자 함수가 평가될 때, 프로토타입도 바로 만들어진다.
    - 생성자 함수만 프로토타입 프로퍼티 갖는다.
    - 이게 생성자 함수 프로토타입 가리킴
    - 생성자 함수 프로토타입엔 constructor 프로퍼티 생성
    - 이게 생성자 함수 가리킴
- 모든 객체는 [[Prototype]] 내부슬롯 갖고 있다.
    - 모든 객체는 prototype 체인에 있다.
- 생성자 함수만 프로토타입 프로퍼티 갖는다.
- prototype 객체 안에 있는 것도 메소드야...!!!

## 3.  암묵적 전역 이후 명시적 선언으로 동일한 식별자 추가하면 암묵적은 무시되나?

```jsx
var x = 1;
function foo() {
  y = 2;
  console.log(x); // 1
}
foo();
console.log(y); // 2
console.log(window.y) //2

var y = 5;
console.log(y) //5
console.log(window.y) //5

delete y; // false
```

- 무시는 아니다.!
- 전역 변수든, 전역 객체의 프로퍼티로서 할당이든, 어쨋든 둘다 전역 객체이 프로퍼티로 있다.
    - `window.y`
    - 때문에 그냥 값이 재할당 되는 것이다.
    

## 4.

![실행컨텍스트](/assets/img/study/실행컨텍스트1.png)

![실행컨텍스트](/assets/img/study/실행컨텍스트2.png)

- 전역 안에 블록이 있는 경우
    - 실행 컨텍스트가 새로 생기는 것 아니다.
    - 블록 렉시컬 환경만 생긴다.
    - const, let 선언시 > 블록 렉시컬 환경의 환경 레코드에 선언적 환경 레코드 생성
    - var 선언시 > 별도 스코프 안만듬 > 전역 환경 레코드의 객체 환경 레코드에 저장
- 함수 안에 블록이 있는 경우
    - 실행 컨텍스트가 새로 생기는 것이 아니다.
    - 블록 렉시컬 환경만 생긴다.
    - const, let 선언시 >  블록 렉시컬 환경의 환경 레코드에 선언적 환경 레코드 생성
    - var 선언시 > 별도 스코프 안만듬 > 함수 렉시컬 환경의 환경 레코드에 저장
- 왜 전역 환경 레코드만 객체 환경 레코드, 선언적 환경 레코드로 구분될까?
    - 초창기, 전역객체 (window) 자체가 전역 스코프였어. 선언적 환경은 존재하지도 않음
    - 모든 전역 변수가 전역 객체 프로퍼티가 되는 문제점 발생 > const, let 등장
    - 기존 코드들을 못쓰게 할 수는 없으니, 이걸 구분할 새로운 공간인 선언적 환경 등장
- 함수 렉시컬 환경의 환경 레코드는 왜 구분을 안해?
    - 함수 내에서 선언한 var가 전역으로 쓰일 수 있어? No
    - 그럼 let, const 랑 다를게 있어? No
    - 그래서 구분 안짓는다.
- 블록 렉시컬 환경의 환경 레코드는 선언적 환경 레코드만 갖는다.
    - var 로 선언한 애들은 블록 스코프에 안되니까 상위 스코프(전역,함수) 스코프에 저장되겠지. 코드는 블록에 있더라도!

```jsx
function test () {
	let x  = 1

	console.log("hello")
	{
		let b = 1 // test 렉시컬 환경 레코드가 아닌 그 위 블록 렉시컬 환경에 저장
		var c = 1 // test 렉시컬 환경 레코드에 저장
	}

}

test()
```

## 5. 생성자 함수, 프로토타입, 인스턴스 제대로 이해하기

![생성자함수](/assets/img/study/생성자함수.png)<br>