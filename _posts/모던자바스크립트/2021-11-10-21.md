---
layout: post
title: "21. 빌트인 객체"
subtitle: "빌트인 객체"
categories: 모던자바스크립트
comments: true
tags: 
---

- 목차
  - [1. 자바스크립트 객체의 분류](#)
  - [2. 표준 빌트인 객체](#)
  - [3. 원시값과 래퍼 객체](#)
  - [4. 전역 객체](#)


<br>

## 1. 자바스크립트 객체의 분류

- 표준 빌트인 객체
    - ECMAScript 사양에 정의된 객체, 애플리케이션 전역의 공통 기능 제공
    - js 실행 환경과 관계없이 언제나 사용 가능
    - 전역 객체의 프로퍼티로서 제공
- 호스트 객체
    - ECMAScript에 정의되어 있진 않지만, js 실행 환경에서 추가로 제공하는 객체
- 사용자 정의 객체
    - 사용자가 직접 정의한 객체

## 2. 표준 빌트인 객체

- Math, Reflect, JSON 을 제외한 표준 빌트인 객체는 생성자 함수
- 생성자 함수 && 표준 빌트인 : 프로토타입 메서드, 정적 메서드 제공 > 인스턴스 생성 가능
- 생성자 함수 x && 표준 빌트인 : 정적 메서드만 제공
- 빌트인 정적 메서드 : 인스턴스 없이도 호출 가능
    - `Number.isInteger(0.5)`
    

## 3. 원시값과 래퍼 객체

- 문자열, 숫자, 불리언 원시값이 있는데, 이 객체를 생성하는 String, Number 등의 표준 빌트인 생성자 함수가 왜 있을까?

```jsx
const str = "hello"

console.log(str.length)
// 원시값을 어떻게 객체처럼 사용하지?
// 마침표 표기법으로 접근하면 Js엔진이 일시적으로 원시값을 연관된 객체로 변환
```

- 원시값을 객체처럼 사용하면, js엔진은 암묵적으로 연관된 객체를 생성하여, 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.
- 이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체 : 래퍼 객체
- 동작 원리
    - 문자열에 마침표 표기법으로 접근 > 래퍼객체 (String 생성자 함수의 인스턴스) todtjd
    - 문자열이 래퍼 객체의 [[StringData]]내부 슬롯에 할당
    - 객체 처리 종료 >  [[StringData]] 내부 술롯에 할당된 값을 식별자에게 돌려준다.
    - 래퍼 객체는 가비지 컬렉션의 대상이 된다.
    
    ```jsx
    const str = "hello";
    str.name = "Lee";
    // 래퍼 객체 생성 및 소멸
    
    console.log(str.name); //undefined
    // 새로운 래퍼 객체 생성
    
    ```
    
- 심벌도 래퍼 객체 생성 > 리터럴 표기법으로 생성 불가, Symbol 함수를 통해서만 해야함
- Number, String, Boolean 인스턴스 생성 시 new 사용 권장 x
- null, undefined는 래퍼 객체 생성 x > 객체처럼 쓰면 에러

## 4. 전역 객체

- 코드가 실행되기 이전 단계에 js 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체, 어떤 객체에도 속하지 않은 최상위 객체
- js 환경에 따라 이름이 다르다
    - 브라우저 : window
    - node : global
- global this : ES11에서 도입, 브라우저, node 환경에서 전역 객체를 가리키던 다양한 식별자를 통일한 것
- 전역 객체 프로퍼티
    - 표준 빌트인 객체
    - 환경에 따른 호스트 객체
    - var 키워드로 선언한 전역 변수, 전역 함수
- 전역 객체 : 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체
    - 프로토타입 상속 관계상에서 최상위 객체다라는 것 아니다.
    - 전역객체 자신은 어떤 객체의 프로퍼티도 아니다.
    - 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다.
- 전역 객체 특징
    - 개발자가 의도적으로 생성 x > 전역객체를 생성할 수 있는 생성자 함수 x
    - 전역객체의 프로퍼티를 참조할 때는 window(global) 생략 가능
    - 표준 빌트인 객체를 프로퍼티로 가지고 있다.
    - js 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.
    - var 키워드로 선언한 전역 변수와, 선언하지 않은 변수에 값을 할당한 암묵적 전역, 전역함수를 프로퍼티로 갖는다.
    - let, const 로 선언한 전역 변수는 전역 객체의 프로퍼티 x > 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재
    - 하나의 전역 객체 window 를 공유한다. (분리된 js 코드가 하나의 전역을 공유)
    

### 빌트인 전역 프로퍼티

- 전역 객체의 프로퍼티 > 애플리케이션 전역에서 사용하는 값
- Infinity : 무한대를 나타내는 숫자값
- NaN : 숫자가 아님
- undefined

### 빌트인 전역 함수

- 애플리케이션 전역에서 호출할 수 있는 빌트인 함수, 전역 객체의 메서드
- eval : js 코드를 나타내는 문자열을 인수로 전달받는다.
    - 전달받은 문자열이 표현식 > 런타임에 평가하여 값 생성
    - 전달받은 문자열이 표현식 x > 런타임에 실행
    
    ```jsx
    eval("1+2;");
    // 평가 > 실행
    
    eval("var x = 5");
    // 실행
    
    console.log(x); //5
    
    const o = eval("({a:1})");
    // 객체 리터럴은 반드시 괄호로 둘러 싼다.
    console.log(o);
    
    const f = eval("(function(){return 1;})"); //{ a: 1 }
    // 함수 리터럴은 반드시 관호로 둘러싼다.
    console.log(f()); //1
    ```
    
    - eval 함수는 자신이 호출된 위치에 해당하는 기존의 스코르르 런타임에 동적으로 수정
        - strict 모드에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프 생성
        - 인수로 전달받은 문자열 코드가 let, const 키워드를 사용한 변수 선언문이면, 암묵적으로 strict mode 적용
    - eval 함수 사용 금지 (보안 취약, 최적화 수행 x)
- isFinite : 전달받은 인수가 정상적인 유한수인지 검사하여 유한수면 true, 무한수면 false 반환
    - 전달받은 인수가 숫자가 아니면, 숫자로 타입 변환 후 검사 수행
    - NaN으로 평가되면 false
- isNaN : 전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환
    - 전달받은 인수가 숫자가 아니면 숫자로 타입 변환 후 검사 수행
- parseFloat : 전달받은 문자열 인수를 부동 소수점 숫자, 실수로 해석(parsing)하여 반환
    - 공백으로 구분되면 첫번째만
    - `parseFloat('34 40 55')` > 34
    - 앞뒤 공백 무시
    - `parseFloat(" 40  ")` > 40
- parseInt : 전달받은 문자열 인수로 정수로 해석하여 반환
    - 전달받은 인수가 문자열이 아니면 문자열로 변환 후, 정수로 해석
    - 두번째 인수로 진법을 나타내는 기수(2~36) wjsekf rksmd
    - 기수를 지정하면, 첫번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석하여 반환
        - 반환값은 언제나 10진수
        - 기수를 생략하면 첫번째 인수로 전달된 문자열을 10진수로 해석하여 반환
        - 기수를 지정하지 않고 문자열에 0x, 0X로 시작하면 16진수로 해석
        - 2진수, 8진수 리터럴(0b, 0o)는 제대로 해석 x
    - 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환 > `Nuber.prototype.toString`
    - 첫번째 문자열의 첫번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN 반환
- encodeURI / decodeURI
    - encodeURI : 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩
    - URI : 인터넷에 있는 자원을 나타내는 유일한 주소
    - 인코딩 : URI의 문자들을 이스케이프 처리하는 것
    - 이스케이프 처리 : 네트워크를 통해 정보를 공유할 때, 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
    - URL 은 아스키 문자 셋으로만 구성되어야 한다. > 한글, 특수문자 등을 이스케이프 처리해야 한다.
    - decodeURI : 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩
- encodeURIComponent / decodURIComponent
    - encodeURIComponent : URI 구성 요소를 인수로 전달받안 인코딩
        - 인수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주
        - 쿼리 스트링 구분자로 사용되는 = ? & 까지 인코딩
        - encodeURI  : 매개변수로 전달된 문자열을 완전한 URI 전체 > 쿼리 스트링 구분자 인코딩 x
    - decodURIComponent  : 매개변수로 전달된 URI 구성 요소를 디코딩한다.
    

### 암묵적 전역

- 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.
- `y = 20` 을 `window.y = 20` 으로 해석 > 전역 객체의 프로퍼티를 동적으로 생성
    - 마치 전역 변수처럼 동작
    - 이러한 현상을 암묵적 전역
    - y는 변수가 아니야 > 변수 호이스팅 x
    - 암묵적 전역은 전역객체의 프로퍼티이므로 delete 연산으로 삭제 가능
    - but 전역변수는 delete 연산으로 삭제 불가능

```jsx
console.log(x);
console.log(y); //ReferenceError: y is not defined

var x = 10;
function foo() {
  y = 20;
}
foo();

console.log(x + y); //30

console.log(global.y); //20
delete global.y;
console.log(global.y); //undefined

console.log(global.x); //10
delete global.x;
console.log(global.x); //10
```