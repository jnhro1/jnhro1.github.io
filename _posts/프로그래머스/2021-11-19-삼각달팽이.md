---
layout: post
title: "[Level2] 삼각달팽이"
subtitle: "삼각달팽이"
categories: 프로그래머스
comments: true
tags: Level2
---


<br>

## 삼각달팽이

[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/68645) <br><br>

### 나의 풀이
```js
function solution(n) {
  const answer = new Array(n).fill().map((_, i) => new Array(i + 1));

  let count = 0;
  let x = -1;
  let y = 0;
  while (n > 0) {
    for (let i = 0; i < n; i++) answer[++x][y] = ++count;
    for (let i = 0; i < n - 1; i++) answer[x][++y] = ++count;
    for (let i = 0; i < n - 2; i++) answer[--x][--y] = ++count;
    n -= 3;
  }

  return answer.flat();
}
```

규칙성을 발견하면 간단한 문제였다.
아래 > 오른쪽 > 위 로 올라가면서 각각 횟수가 1씩 감소한다는 것
이렇게 3번 과정이 계속 반복된다는 것

이 규칙성을 발견하기 전까지는 굉장히 많은 삽질을 했다..ㅎ

<br><br>

## 괄호 회전하기

[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/76502) <br><br>

```js
function solution(s) {
  let queue = [...s];

  function rotation(arr) {
    arr.push(arr.shift());
    return arr;
  }

  function isRight(arr) {
    let stack = [];
    for (let i = 0; i < arr.length; i++) {
      stack.push(arr[i]);
      if (
        (arr[i] == ')' && stack[stack.length - 2] === '(') ||
        (arr[i] == '}' && stack[stack.length - 2] === '{') ||
        (arr[i] == ']' && stack[stack.length - 2] === '[')
      ) {
        stack.pop();
        stack.pop();
      }
    }
    return stack.length ? false : true;
  }
  let cnt = 0;
  for (let i = 0; i < s.length; i++) {
    if (isRight(queue)) cnt++;
    queue = rotation(queue);
  }
  return cnt;
}
```

isRight 함수가 썩 맘에들지 않는다...<br>
더 좋은 방법이 있을것 같은데,,, <br>
이 글을 적던 중 다른 사람의 풀이를 보고 조금 더 좋은 방향을 찾았다.<br><br>

```js
function solution(s) {
  let queue = [...s];

  function rotation(arr) {
    arr.push(arr.shift());
    return arr;
  }

  function isRight(arr) {
    let stack = [];
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] == ')' && stack[stack.length - 1] === '(') stack.pop();
      else if (arr[i] == '}' && stack[stack.length - 1] === '{') stack.pop();
      else if (arr[i] == ']' && stack[stack.length - 1] === '[') stack.pop();
      else {
        stack.push(arr[i]);
      }
    }
    return stack.length ? false : true;
  }
  let cnt = 0;
  for (let i = 0; i < s.length; i++) {
    if (isRight(queue)) cnt++;
    queue = rotation(queue);
  }
  return cnt;
}
````

stack에 무조건 먼저 Push를 하고 pop을 두번 하는 과정이 마음에 안들었는데<br>
else 가 있었다는걸... 깨달았다<br>
바본가..? 왜 else를 까먹었지?<br>
최대한 함수형 프로그래밍으로 짜려했는데, rotation을 계속 해줘야했고, 원본 배열이 유지되는 경우가 없었어서<br>
절차형으로 짜게 된 거 같다.<br>