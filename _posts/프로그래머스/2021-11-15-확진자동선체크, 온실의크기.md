---
layout: post
title: "[알고리즘퀴즈] 확진자동선체크, 온실의크기"
subtitle: "확진자동선체크"
categories: 프로그래머스
comments: true
tags: Level2
---


<br>

## 확진자동선체크

![확진자동선체크](/assets/img/study/확진자동선체크.png)<br>

### 나의 코드
```js
function solution(history, infected) {
  let index = history.indexOf(-infected);
  let answer = [];
  do {
    let temp = history.slice(0, index + 1);
    answer = [...temp.filter(v => v > 0 && v !== infected)];
    let i = 0;
    while (temp.indexOf(infected) > i++) {
      if (temp[i] < 0) {
        answer.splice(answer.indexOf(-temp[i]), 1);
      }
    }

    // 반복
    history = history.slice(index + 1);
    index = history.indexOf(-infected);
  } while (index !== -1);
  return [...new Set(answer)].sort((x, y) => x - y);
}

console.log(solution([3, 2, -3, 1, -1, -2, 4, -4, 1, -1], 2));
console.log(solution([2, 4, 3, -3, 3, -2, 1, -3, -1, -4], 4));
console.log(solution([1, -1], 1));
console.log(solution([7, -7, 2, 5, 1, 4, 9, -9, -2, 3, -1, -5, 6, 10, -10, 7, -4, -6, 8, -7, 4, -3, 3, -8, -3, -4], 1));

//[ 1, 3 ]
// [ 1, 2, 3 ]
// []
// [ 2, 3, 4, 5, 9 ]
```

1. 확진자의 퇴장을 기준으로 배열을 자른다. (기준 배열)
2. 확진자가 아니면서, 입장한 사람을 배열에 추가한다.
3. 확진자 입장 전, 퇴장했던 사람을 2에서 구한 배열에서 제거한다.
4. 확진자가 나머지 배열에 없을 때까지 1,2,3 과정을 반복한다.
5. 최종 배열에서 set으로 중복을 없앤 후 오름차순으로 정렬한다.


<br><br>

## 온실의크기

![온실의크기](/assets/img/study/온실의크기.png)<br>

### 나의 코드

```js
function solution(field, n) {
  let row = field.length;
  let col = field[0].length;
  let answer = [];

  for (let i = 0; i <= col - n; i++) {
    for (let j = 0; j <= row - n; j++) {
      let cnt = 0;
      for (let k = i; k < i + n; k++) {
        for (let l = j; l < j + n; l++) {
          if (field[k][l] === 1) cnt++;
        }
      }
      answer.push(cnt);
    }
  }
  return Math.max(...answer);
}

console.log(solution([[1,0,1],[0,0,1],[0,1,1]], 2)); //3
console.log(solution([[0,0,0,1],[1,1,0,0],[0,1,0,0],[0,0,1,0]], 3)); //4
console.log(solution([[1,1,0,0,1],[0,1,1,0,0],[1,1,0,0,0],[0,0,1,1,0],[1,0,1,1,0]], 3)); //6
console.log(solution([[0]], 1)); //0
```

1. 가능한 n*n 좌측상단 지점 for문 구현하기 (i, j)
2. 해당 지점에서 우측으로 n, 아래로 n만큼 이동하며 갯수 구하기
3. 가장 큰 cnt 출력하기